
Shader
{
    Name = "Simple";
    Type = SHADER_FORWARD;
}

Global
{
	#include "common/common.hlsl"

	struct VS_Input
	{
		#include "common/vertex_input.hlsl"
	};

	struct PS_Input
	{
		#include "common/pixel_input.hlsl"
	};
	
	//Property<float> vRoughness(Name = "Roughness", UiGroup = "Specular");
	//Property<float> vMetallic(Name = "Metallic", UiGroup = "Specular");

	Property<Texture2D> vRoughness(Name = "Roughness", UiGroup = "Specular");
	Property<Texture2D> vMetallic(Name = "Metallic", UiGroup = "Specular");

	Property<Texture2D> vEmission(Name = "Emmision", UiGroup = "Color");
	Property<float> vEmissionIntensity(Name = "Emmision Intensity", UiGroup = "Color");
}

VS
{
	#include "common/vertex.hlsl"
	
    PS_Input Main(VS_Input input)
    {
		PS_Input output = ProcessVertex(input);

		FinalizeVertex(input, output);
		return output;
    }
}

PS
{
	#include "common/forward_light_data.hlsl"
	#include "common/shadow_data.hlsl"

	#define SHADOW_SAMPLES 8

	static const float PI = 3.14159265359;

	float3 CalculateNormal(PS_Input input)
	{
		float3 normalMap = SampleTexture2D(vNormalMap, input.vTextureCoords).xyz * 2 - 1;
		normalMap = normalize(lerp(float3(0, 1, 0), normalMap, vNormalIntensity));
		if (vNormalIntensity == 0)
			return normalize(input.vNormalWs);

		float3x3 TBN = float3x3(input.vTangentUWs, input.vTangentVWs, input.vNormalWs);
		return normalize(mul(TBN, normalMap));
	}

	float DistributionGGX(float3 N, float3 H, float roughness)
	{
		float a = roughness * roughness;
		float a2 = a * a;
		float NdotH = max(dot(N, H), 0.0);
		float NdotH2 = NdotH * NdotH;

		float nom = a2;
		float denom = (NdotH2 * (a2 - 1.0) + 1.0);
		denom = PI * denom * denom;

		return nom / denom;
	}

	float GeometrySchlickGGX(float NdotV, float roughness)
	{
		float r = (roughness + 1.0);
		float k = (r*r) / 8.0;

		float nom   = NdotV;
		float denom = NdotV * (1.0 - k) + k;

		return nom / denom;
	}

	float3 divide(float a, float3 b)
	{
		float x = b.x / a;
		float y = b.y / a;
		float z = b.z / a;
		return float3(x, y, z);
	}

	float GeometrySmith(float3 N, float3 V, float3 L, float roughness)
	{
		float NdotV = max(dot(N, V), 0.0);
		float NdotL = max(dot(N, L), 0.0);
		float ggx2 = GeometrySchlickGGX(NdotV, roughness);
		float ggx1 = GeometrySchlickGGX(NdotL, roughness);

		return ggx1 * ggx2;
	}
	
	float3 fresnelSchlick(float cosTheta, float3 F0)
	{
		//return F0 + mul(pow(max(1.0 - cosTheta, 0.0), 5.0), (1.0 - F0));
		return F0 + (1.0 - F0) * pow(clamp(1.0 - cosTheta, 0.0, 1.0), 5.0);
	}

	float3 fresnelSchlickRoughness(float cosTheta, float3 F0, float roughness)
	{
		return F0 + mul(pow(clamp(1.0 - cosTheta, 0.0, 1.0), 5.0), max(float3(1.0 - roughness, 1.0 - roughness, 1.0 - roughness), F0) - F0);
	}

	float4 DirLight(float3 posWs, float3 normal, float roughness, float metallic, float3 diffuse, FDirectionalLight light)
	{
		// Is in shadow?
		float shadow = 0.f;
		if (light.shadowIndex != -1)
		{
			for (int i = 0; i < 4; i++)
			{
				float4x4 shadowMat = vSunShadowMatrix[0];
				switch (i)
				{
				case 1:
					shadowMat = vSunShadowMatrix[1];
					break;
				case 2:
					shadowMat = vSunShadowMatrix[2];
					break;
				case 3:
					shadowMat = vSunShadowMatrix[3];
					break;
				}

				float4 fragPosLightSpace = mul(shadowMat, float4(posWs, 1.f));
				float3 projCoords = fragPosLightSpace.xyz / fragPosLightSpace.w;
				projCoords = projCoords * 0.5 + 0.5;

				if (projCoords.x < 1 && projCoords.y < 1 && projCoords.x > 0 && projCoords.y > 0)
				{
					if (i > 1)
					{
						float shadowDepth = SampleTexture2DLOD(vSunShadow, float2(projCoords.x / 4 + (0.25f * i), 1.f - projCoords.y), 0).r;
						if (fragPosLightSpace.z - 0.0002 > shadowDepth)
							return float4(0.f, 0.f, 0.f, 0.f);
					}
					else
					{
						float averageShadow = 0.f;

						for (int j = 0; j < SHADOW_SAMPLES * SHADOW_SAMPLES; j++)
						{
							uint texHeight;
							uint texWidth;
							uint texLevels;
							vSunShadow.GetDimensions(0, texHeight, texWidth, texLevels);

							float pixelSize = 1.f / texHeight;
							float2 offset = float2((float(j % SHADOW_SAMPLES) - 0.5f), ((float(j) / SHADOW_SAMPLES) - 0.5f)) * pixelSize;
							float2 mapUv = float2(projCoords.x / 4 + (0.25f * i), 1.f - projCoords.y);

							mapUv = mapUv + offset;
							mapUv.x = clamp(mapUv.x, 0.25f * i, (0.25f * i) + 0.248888f);
							mapUv.y = clamp(mapUv.y, 0, 1);

							float shadowDepth = SampleTexture2DLOD(vSunShadow, mapUv, 0).r;

							if (fragPosLightSpace.z - (i == 0 ? vSunShadowBias : 0.0005) > shadowDepth)
								averageShadow = averageShadow + 1.f;
						}

						shadow = averageShadow / (SHADOW_SAMPLES * SHADOW_SAMPLES);
						break;
					}
				}
			}
		}

		float3 V = normalize(vCameraPos - posWs);
		float3 H = normalize(V + light.direction);
		float3 radiance = light.color * light.intensity;

		float3 F0 = float3(0.04, 0.04, 0.04);
		F0 = lerp(F0, diffuse, metallic);
		float3 F = fresnelSchlick(max(dot(H, V), 0), F0);

		float NDF = DistributionGGX(normal, H, roughness);
		float G = GeometrySmith(normal, V, light.direction, roughness);

		float3 numerator = NDF * G * F;
		float denominator = 4.0 * max(dot(normal, V), 0.0) * max(dot(normal, light.direction), 0.0)  + 0.0001;
		float specular = numerator / denominator;

		float3 kS = F;
		float3 kD = float3(1, 1, 1) - kS;
		kD = kD * (1.0 - metallic);
		float NdotL = max(dot(normal, light.direction), 0);
		return float4((kD * diffuse / PI + specular) * radiance * NdotL, length(specular)) * (1 - shadow);
	}

	float4 PointLight(float3 posWs, float3 normal, float roughness, float metallic, float3 diffuse, FPointLight light)
	{
		float3 V = normalize(vCameraPos - posWs);
		float3 L = normalize(light.position - posWs);
		float3 H = normalize(V + L);

		float distance = length(light.position - posWs);
		//float attenuation = 1 / (distance * distance);
		float attenuation = 1 - saturate(distance / light.range);
		float3 radiance = light.color * attenuation * light.intensity;

		float3 F0 = float3(0.04, 0.04, 0.04);
		F0 = lerp(F0, diffuse, metallic);
		float3 F = fresnelSchlick(max(dot(H, V), 0), F0);

		float NDF = DistributionGGX(normal, H, roughness);
		float G = GeometrySmith(normal, V, L, roughness);

		float3 numerator = NDF * G * F;
		float denominator = 4.0 * max(dot(normal, V), 0.0) * max(dot(normal, L), 0.0)  + 0.0001;
		float3 specular = numerator / denominator;

		float3 kS = F;
		float3 kD = float3(1, 1, 1) - kS;
		kD = kD * 1.0 - metallic;

		float NdotL = max(dot(normal, L), 0);

		return float4((kD * diffuse / PI + specular) * radiance * NdotL, (specular.r + specular.g + specular.b) / 3);
	}

    float4 Main(PS_Input input) : SV_TARGET
    {
		float distanceFromCam = length(vCameraPos - input.vPositionWs);
		int texLod = (int)floor(distanceFromCam / 10);

		//float3 debugLod = lerp(float3(0.4f, 1, 0.4f), float3(1, 0.4f, 0.4f), min((float)texLod / 6.0f, 1.f));
		//float3 debugLod = float3((float)texLod / 6.f, 1.f, 1.f);

		float4 diffuse = SampleTexture2DLOD(vBaseColor, input.vTextureCoords, texLod) /*  * vColorTint */;
		float4 emmision = SampleTexture2D(vEmission, input.vTextureCoords) * vEmissionIntensity;
		float rough = SampleTexture2D(vRoughness, input.vTextureCoords).r;
		float metallic = SampleTexture2D(vMetallic, input.vTextureCoords).r;

		//float4 diffuse = float4(1, 1, 1, 1);
		float3 d2 = diffuse.xyz;
		float3 normal = CalculateNormal(input);
		//float3 normal = normalize(input.vNormalWs);

		float4 outColor = float4(0, 0, 0, 0);

		// FPointLight l;
		// l.range = 10;
		// l.intensity = 15;
		// l.position = float3(2, 2, 0);
		// l.color = float3(1, 1, 1);
		// outColor = outColor + (PointLight(input.vPositionWs, normal, d2, l));

		// l.intensity = 5;
		// l.position = float3(1.5, -0.5, 0.5);
		// l.color = float3(1, 0, 0);
		// outColor = outColor + (PointLight(input.vPositionWs, normal, d2, l));

		// l.position = float3(1.5, -0.5, -0.5);
		// l.color = float3(0, 0, 1);
		// outColor = outColor + (PointLight(input.vPositionWs, normal, d2, l));

		for (int i = 0; i < numDirectionalLights; i++)
		{
			outColor = outColor + DirLight(input.vPositionWs, normal, rough, metallic, d2, directionalLights[i]);
		}

		for (int i = 0; i < numPointLights; i++)
		{
			outColor = outColor + PointLight(input.vPositionWs, normal, rough, metallic, d2, pointLights[i]);
		}

		//float3 amb = float3(0.01, 0.01, 0.01) * d2;
		//float3 color = amb + outColor;
		float3 color = outColor.xyz + emmision.xyz;

		const float gamma = 1.6;

		//color = color / (color + float3(1, 1, 1));
		color = pow(abs(color), abs(float3(1 / gamma, 1 / gamma, 1 / gamma)));

		return float4(color.xyz, min(1, diffuse.a * vAlpha + outColor.w));
    }
}
